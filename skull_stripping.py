# -*- coding: utf-8 -*-
"""Skull_Stripping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i4J30-tGzIOJFH2DeMepkqNe4QOcDPQF

https://github.com/CBICA/BrainMaGe/blob/master/BrainMaGe/utils/intensity_standardize.py
"""

import numpy as np
from skimage.transform import resize
import nibabel as nib
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

img = nib.load('/content/drive/My Drive/Datasets/nifti/output.nii.gz')
data = img.get_fdata()

"""Your pad_image function seems to be designed to pad a given image to a specific size: [240, 240, 160]."""

def pad_image(image,shape):
    #"""Pad the image to a particular size.

    #This function pads the image to a space of [240, 240, 160] with zeros.

    #Arguments:
        #image {numpy.ndarray} -- Image of any standard shape [x, y, z].

    #Returns:
        #numpy.ndarray -- Padded image.
    #"""
    padded_image = np.copy(image)
    for i in range(len(shape)):
      if i == 0:
        shape0 = shape[0]
      elif i == 1:
        shape1 = shape[1]
      elif i == 2:
        shape2 = shape[2]
        print(shape2)
      elif i == 3:
        shape3 = shape[3]
    # Resize the image to [240, 240, 160]
    # Padding on X axes
    if image.shape[0] < shape0:
        pad_width = ((shape0 - image.shape[0]) // 2, (shape0 - image.shape[0]) // 2)
        padded_image = np.pad(padded_image, ((pad_width), (0, 0), (0, 0)),
                              mode="constant", constant_values=0)

    # Padding on Y axes
    if image.shape[1] < shape1:
        pad_width = ((0, 0), ((shape1 - image.shape[1]) // 2, (shape1 - image.shape[1]) // 2), (0, 0))
        padded_image = np.pad(padded_image, ((pad_width)),
                              mode="constant", constant_values=0)

    # Padding on Z axes
    if image.shape[2] < shape2:
        pad_width = ((0, 0), (0, 0), (0, (shape2 - image.shape[2])))
        padded_image = np.pad(padded_image, ((pad_width)),
                              mode="constant", constant_values=0)
        print('yes',pad_width,padded_image)
    return padded_image

"""
Your preprocess_image function looks quite comprehensive, aiming to preprocess both normal images and masks to a desired resolution."""

def preprocess_image(image, is_mask=False, target_spacing=(1.875, 1.875, 1.25)):
  # Get new_pace from the user
    def get_new_spacing_from_user():
        shape_str = input("Enter the desired space (comma-separated, e.g., 1,1,1): ")
        new_spacing = tuple(map(int, shape_str.split(',')))
        return new_spacing


    def get_new_shape_from_user():
        shape_str = input("Enter the desired shape (comma-separated, e.g., 240,240,160): ")
        new_shape = tuple(map(int, shape_str.split(',')))
        return new_shape
    #"""Preprocess an image depending on whether it is a mask image or not.

    #This function preprocesses a given image to a particular resolution and returns a preprocessed image.

    #Args:
        #image (nibabel image): Image to be preprocessed.
        #is_mask (bool, optional): Whether the incoming image is a mask. Defaults to False.
        #target_spacing (tuple, optional): Target spacing to be used. Defaults to (1.875, 1.875, 1.25).

    #Returns:
        #numpy.ndarray: Preprocessed and normalized image.
    #"""
    original_spacing = image.header.get_zooms()
    shape = image.header.get_data_shape()
    print(shape)
    new_image = image.get_fdata()
    new_spacing = get_new_spacing_from_user()
    new_shape1 = get_new_shape_from_user()
    if is_mask:
        order = 0
    else:
        order = 3

    if original_spacing != new_spacing or shape != new_shape1:
        new_shape = [
            int(np.round(original_spacing[i] / new_spacing[i] * shape[i])) for i in range(3)
        ]
        new_image = resize(new_image, new_shape, order=order, mode="edge", cval=0, anti_aliasing=False)

    if shape != new_shape:
        new_image = pad_image(new_image,new_shape1)
        print('new_image: ',new_image.shape)
    new_image = resize(new_image, (128, 128, 128), order=order, mode="edge", cval=0, anti_aliasing=False)

    if not is_mask:
        new_image = (new_image - np.percentile(new_image[new_image >= new_image.mean()], 2)) / np.percentile(new_image[new_image >= new_image.mean()], 95)

    return new_image.astype(np.int8) if is_mask else new_image.astype(np.float32)

new_image = preprocess_image(img, is_mask=False, target_spacing=(1.875, 1.875, 1.25))
print(new_image.shape)

def plot_slice(image, title):
    # Take a slice from the middle of the image
    image_data = image.get_fdata()
    slice_index = image_data.shape[2] // 2
    slice_data = image_data[:, :, slice_index]

    plt.imshow(slice_data, cmap='gray')
    plt.title(title)
    plt.axis('off')
    plt.show()

# Plot a slice from the original image
plot_slice(img, title='Original Image')

def plot_slice(image, title):
    # Take a slice from the middle of the image
    slice_index = image.shape[2] // 2
    slice_data = image[:, :, slice_index]

    plt.imshow(slice_data, cmap='gray')
    plt.title(title)
    plt.axis('off')
    plt.show()

# Assuming new_image is the preprocessed and normalized image
plot_slice(new_image, title='preprocess Image')

import numpy as np
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu
from skimage.morphology import binary_closing, binary_dilation, binary_erosion, ball

def skull_strip(image):
    # Apply Otsu's thresholding to segment the brain
    threshold_value = threshold_otsu(image)
    brain_mask = image > threshold_value

    # Perform morphological operations to further refine the brain mask
    structuring_element = ball(5)  # Adjust the radius as needed
    brain_mask = binary_closing(brain_mask, structuring_element)
    brain_mask = binary_erosion(brain_mask, structuring_element)

    # Apply the brain mask to the original image to extract the brain
    brain_image = np.copy(image)
    brain_image[~brain_mask] = 0

    return brain_image

# Assuming new_image is the preprocessed and normalized image
stripped_brain_image = skull_strip(new_image)

# Plot a slice from the stripped brain image
plot_slice(stripped_brain_image, title='Stripped Brain Image')